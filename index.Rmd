---
title: ""
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(glmmTMB)
library(ggplot2)
library(tidyr)
library(bipartite)
library(igraph)
library(jtools)
library(vegan)
library(rnetcarto)
library(sjstats)
library(knitr)
library(sjPlot)
```

#Desert shrub facilitation shapes pollination network topology
\newline
***
\newline
```{r, loading clean datasets}
#dataset with aggregated visits (i.e. number of visits per rep, no pollinator ID) with joined covariates & calculated densities
#contains reps with zero visits
#wrangling all done using visits.R

data <- read.csv("Data/Output/visitation_cleaned.csv")
data <- data %>% mutate(time = ifelse(day <= 10, "early", 
                                            ifelse(day > 10, "later", "mid")))

#long version with pollinator ID, list of visits only for building network 
visits <- read.csv("Data/visitation_data.csv")
visits$Quantity <- as.numeric(as.character(visits$Quantity))
visits <- dplyr::filter(visits, Quantity>0)
visits$Site <- "site"
visits$ID <- gsub(" ","", visits$ID)
visits$ID <- gsub('\"',"", visits$ID)
visits$Species <- gsub(" ","", visits$Species)
visits$Species <- gsub('\"',"", visits$Species)
sum(visits$Quantity)
visits$uniID <- paste(visits$Species, visits$WP)
#visits <- right_join(cl.con, visits, by = "uniID")
#visits <- right_join(time, visits, by = "uniID")
```

```{r, functions}

#this function creates an adjencancy matrix from the long visit only dataset
#uniID - plant ID, can use to create species/individual/RTU/functional groups networks from dataset
#y is bottom - uniID or plant Species
#z is top - pollinator RTU or functional group
net <- function(x, y, z){
  y <- enquo(y)
  z <- enquo(z)
  fnet <- dplyr::select(x, !!y, !!z, Site, Quantity)
  fnet$Quantity <- as.numeric(fnet$Quantity)
  print(sum(fnet$Quantity))
  long.ag <- fnet %>% group_by(!!y, !!z) %>% summarise(Quantity = sum(Quantity)) 
  print(sum(long.ag$Quantity))
  wide <- spread(long.ag, !!z, Quantity)
  wide[is.na(wide)] <- 0
  wide <- as.data.frame(wide)
  rownames(wide) = wide[,1 ] # the first row will be the header
  rownames(wide) <- wide[,1]
  wide <- select(wide, -!!y)
}

#calculates z-scores
net.zscore = function(obsval, nullval) {
  (obsval - mean(nullval))/sd(nullval)  
}

#creates random network using vegan with fixed marginal totals. Creates 1000 and puts in one big dataframe
ranindices <- function(x){
  y <- permatfull(x, fixedmar = "both", times = 1000)
  y <- y$perm
  y_indices <- map(y, networklevel)
  ran <-  do.call("rbind", y_indices)
  ran <- as.data.frame(ran)
}

#calculates the modularity of 1000 random networks with fixed marginal totals of input and puts in a big dataframe. Bipartite modularity 
ranModules <- function(x){
  y <- permatfull(x, fixedmar = "both", times = 1000)
  y <- y$perm
  z <- list()
  null.mod <- map(y, computeModules)
  for (i in 1:1000){
    ind <- null.mod[[i]]@likelihood
    z <- c(z, ind)
  } 
  do.call(rbind, lapply(z, as.data.frame))
}


```

```{r}
#make an individual network using functional groups
ind1 <- net(visits, uniID, fun.grp)

#project into a unipartite network
one1 <- as.one.mode(ind1, fill = 0, project = "lower", weight = "TRUE")

#calculate centrality measures
one1 <- graph_from_adjacency_matrix(one1)
cls1 <- closeness(one1)
ei1 <- eigen_centrality(one1)
bt1 <- betweenness(one1)
dg1 <- degree(one1)

#cbind and join to main covariate dataset
dat1 <- as.data.frame(cbind(cls1, ei1$vector, bt1, dg1))
dat1$uniID <- row.names(dat1)
all <- left_join(dat1, data, by = "uniID")

#betweenness is zero inflated so a binary variable
all <- mutate(all, btbin = ifelse(bt1 == 0, 0, 1))

#filter out the over zero part to model separately
bt <- filter(all, bt1 > 0)
```

```{r, specieslevel indices}
#calculate species level indices
sp <- specieslevel(ind1, index = "effective partners")
pl <- sp[2]
pl <- as.data.frame(pl)
pl$uniID <- row.names(pl)
all <- left_join(pl, all, by = "uniID")
```

```{r, population proportions}

#unweighted network
un <- as.one.mode(ind1, fill = 0, project = "lower", weight = "FALSE")

#need to subset
un <- as.data.frame(un)
un$uniID <- row.names(un)
dat <- left_join(all, un, by = "uniID") 
dat <- select(dat, -(18:28))
#calculate number of conspecific interactors
dat <- mutate(dat, cons = ifelse(Species == "PP", rowSums(select (dat, starts_with("PP"))), +
  ifelse(Species == "SC", rowSums(select(dat, starts_with("SC"))),+    ifelse(Species == "HH", rowSums(select(dat, starts_with("HH"))),  +      ifelse(Species == "LT",rowSums(select(dat, starts_with("LT"))), +       ifelse(Species == "AS", rowSums(select(dat, starts_with("AS"))), +      ifelse(Species == "EC", rowSums(select(dat, starts_with("EC"))), +      ifelse(Species == "BW", rowSums(select(dat, starts_with("BW"))), +        ifelse(Species == "EL", rowSums(select(dat, starts_with("EL"))), +  ifelse(Species == "SM", rowSums(select(dat, starts_with("SM"))),
  + ifelse(Species == "SD", rowSums(select(dat, starts_with("SD"))), 0)))))))))))

```

```{r}
#calculate heterospecific interactors

dat <- mutate(dat, hets = ifelse(Species == "PP", rowSums(select(dat, 37:188, 207:265)), +
   ifelse(Species == "SC", rowSums(select(dat, 256:265, 37:206)),+    
 ifelse(Species == "HH", rowSums(select(dat, 37:131, 136:265)),  +      ifelse(Species == "LT",rowSums(select(dat, 37:135, 189:265)), +       ifelse(Species == "AS", rowSums(select(dat, 78:265)), +          ifelse(Species == "EC", rowSums(select(dat, 37:96, 131:265)), +      ifelse(Species == "BW", rowSums(select(dat, 37:77, 96:265)), +        ifelse(Species == "EL", rowSums(select(dat, 37:130, 132:265)), +  ifelse(Species == "SM", rowSums(select(dat, 37:261)),
 + ifelse(Species == "SD", rowSums(select(dat, 37:255, 262:265)), 0)))))))))))


#standardize by abundances
dat <- select(dat, -(37:265))
abun <- dat %>% group_by(Species) %>% count()
dat <- left_join(dat, abun, by = "Species")
dat <- mutate(dat, hetn = 231 - n)
dat <- mutate(dat, st.con = cons/n)
dat <- mutate(dat, st.het = hets/hetn)
dat <- select(dat, uniID, 37:42)
all <- left_join(all, dat, by = "uniID")
```

```{r, nested}
#this step is slow & can be skipped w/o issues. load from csv but code is here.  takes 30 min 
#ne <- nestedcontribution(ind1)
#ne.low <- ne[[2]]
#ne.top <- ne[[1]]
#ne.low$uniID <- row.names(ne.low)
#write.csv(ne.low, "nelow.csv")
#write.csv(ne.top, "netop.csv")
ne.low <- read.csv("nelow.csv")
ne.low <- select(ne.low, -X)
all <- left_join(all, ne.low, by = "uniID")
```

```{r, unipartite modularity}
one1 <- as.one.mode(ind1, fill = 0, project = "lower", weighted = TRUE)
mods <- netcarto(one1)
n1data <- mods[[1]]
n1data <- rename(n1data, uniID = name)
all <- left_join(all, n1data, by = "uniID")
all$module <- as.factor(all$module)
```

#EDA
```{r}
ggplot(data, aes(N.flowers, Quantity)) + geom_point(aes(color = Species)) + geom_smooth(method = lm, se = FALSE, color = "black") 

ggplot(data, aes(shrub.density, Quantity)) + geom_point(aes(color = Species)) + geom_smooth(method = lm, se = FALSE, color = "black") 

pl <- select(all, Species, shrub.density, dg1, st.con, st.het)
pl <- gather(pl,type, prop, 4:5)

ggplot(pl, aes(dg1, prop, color = type)) + geom_point()  +xlab("Degree Centrality") + ylab("Proportion of Population")

ggplot(pl, aes(shrub.density, prop, color = type)) + geom_point() + geom_smooth(method = lm) +xlab("Shrub Density") + ylab("Proportion of Population")
```

#Modelling

```{r, visitation rates}
m1 <- glmmTMB(Quantity ~density + N.flowers + imp.den + (1|Species), family = "nbinom2", data = data)       
summary(m1)
m1p <- glmmTMB(Quantity ~density + N.flowers + imp.den + (1|Species), family = "poisson", data = data)       
summary(m1p)

AIC(m1, m1p)
#negative binomial #2 is the best



m1 <-glmmTMB(Quantity ~density * N.flowers + day + (1|Species), family = "nbinom2", data = data)
m2 <- glmmTMB(Quantity ~ density + N.flowers + day + (1|Species), family = "nbinom2", data = data)       
m3 <- glmmTMB(Quantity ~ density + N.flowers * day + (1|Species), family = "nbinom2", data = data) 
m4 <-glmmTMB(Quantity ~shrub.density * N.flowers + day + (1|Species), family = "nbinom2", data = data)
m5 <- glmmTMB(Quantity ~ shrub.density + N.flowers + day + (1|Species), family = "nbinom2", data = data)       
m6 <- glmmTMB(Quantity ~ shrub.density + N.flowers * day + (1|Species), family = "nbinom2", data = data)
m7 <- glmmTMB(Quantity ~ shrub.density + N.flowers * imp.den + (1|Species), family = "nbinom2", data = data)
m8 <- glmmTMB(Quantity ~ cactus.density + N.flowers * day + (1|Species), family = "nbinom2", data = data)
m9 <- glmmTMB(Quantity ~ con.density + N.flowers * day+ (1|Species), family = "nbinom2", data = data)
mnull <-glmmTMB(Quantity ~  (1|Species), family = "nbinom2", data = data)

kable(AIC(m1, m2, m3, m4, m5, m6, m7, m8, m9, mnull))
summary(m6)
tab_model(m6)
kable(car::Anova(m6, type = 3))
car::vif(lm(Quantity ~ shrub.density + N.flowers * day, data = data))
interact_plot(m6, pred = "N.flowers", modx = "day")

```


{r, centrality measures}
#degree centrality

ggplot(all, aes(dg1)) + geom_density()
m2 <- glmmTMB(dg1 ~ N.flowers+ Quantity + (1|Species), family = "nbinom2", data = all)
m3 <- glmmTMB(dg1 ~ N.flowers+ Quantity + (1|Species), family = "poisson", data = all)
m4 <- glmmTMB(dg1 ~ N.flowers+ Quantity + (1|Species), family = "nbinom1", data = all)
AIC(m2, m3, m4)


m5 <- glmmTMB(dg1 ~ N.flowers +(1|Species), family = "nbinom2", data = all)
summary(m5)
m6 <- glmmTMB(dg1 ~ Quantity+(1|Species), family = "nbinom2", data = all)
m7 <- glmmTMB(dg1 ~ Quantity+ shrub.density + day + (1|Species), family = "nbinom2", data = all)
AIC(m5, m6, m7)

summary(m6)
kruskal.test(dg1 ~ Species, data = all)
a1 <- aov(V2 ~ Species, data = all)
summary(a1)
TukeyHSD(a1)

#betweeness
ggplot(all, aes(bt1)) + geom_density()
b1 <- glmmTMB(btbin ~ shrub.density + Quantity + (1|Species), family = "binomial", data = all)
summary(b1)
car::Anova(b1, type = 2)
b1 <- glmmTMB(log(bt1) ~ Quantity +(1|Species), family = "gaussian", data = bt)
summary(b1)
car::Anova(b1, type = 2)
shapiro.test(resid(b1))

#Eigancentrality
v1 <- glmmTMB(V2 ~ day + Quantity + (1|Species), family = "gaussian", data = all)
summary(v1)
car::Anova(v1, type = 2)
shapiro.test(resid(v1))

vnull <-glmmTMB(V2 ~ (1|Species), family = "gaussian", data = all)
AIC(v1, vnull)
anova(v1, vnull)




#maybe just use the number of sampled plants as an offset??

#conspecifics
all <- mutate(all, uncon = n - cons)

y <- cbind(all$cons, all$uncon)

m3 <- glmmTMB(st.con ~ shrub.density + day +(1|Species), family = "binomial"(link = "logit"), data = all)
summary(m3)

plot(m3)
m4 <- glmmTMB(z ~ shrub.density+ dg1* Quantity+ (1|Species), family = "binomial"(link = "logit"), data = all)
summary(m4)
interact_plot(m4, dg1, Quantity)
overdisp(m4)

m5 <- glmmTMB(y ~ shrub.density+ dg1+Quantity+ (1|Species), family = "binomial"(link = "logit"), data = all)
AIC(m4, m5)
car::Anova(m4, type = 3)

summary(m4)
m5 <- glm(y ~ day+dg1 + shrub.density + Species, family = "quasibinomial"(link = "logit"), data = all)
car::Anova(m5, type = 2)
summary(m5)

m4 <- MASS::glmmPQL(y ~ shrub.density+ dg1, random = ~1|Species, family = "quasibinomial"(link = "logit"), data = all)
summary(m4)

m5 <- MASS::glmmPQL(y ~ shrub.density+ dg1 * Quantity, random = ~1|Species, family = "quasibinomial"(link = "logit"), data = all)
summary(m5)
car::vif(m5)
car::Anova(m5, type = 2)

library(jtools)



cor.test(all$shrub.density, all$dg1)

#heterospecific access
all <- mutate(all, unhet = hetn - hets)
z <- cbind(all$hets, all$unhet)

m1 <- glmmTMB(z ~ day + shrub.density+ dg1+ Quantity+ N.flowers+ (1|Species), family = "binomial"(link = "logit"), data = all)
summary(m1)

m5 <- MASS::glmmPQL(z ~ shrub.density+ dg1 + N.flowers + Quantity + day, random = ~1|Species, family = "quasibinomial"(link = "logit"), data = all)
summary(m5)
car::vif(m5)

cor.test(all$dg1, all$Quantity)
```

#Effective partners
{r}


shapiro.test(all$lower.level.effective.partners)
m1 <- glmmTMB(lower.level.effective.partners ~ density +(1|Species), family = "poisson", data = all)
summary(m1)

m2 <- glmmTMB(lower.level.effective.partners ~ Quantity+day + shrub.density +  (1|Species), family = "poisson", data = all)
summary(m2)
AIC(m1, m2)

m2 <- glmmTMB(lower.level.effective.partners ~ density + (1|Species), family = "nbinom1", data = all)

m1 <- glmmTMB(effective.partners ~ shrub.density +(1|Species), family = "poisson", data = all)
m2 <- glmmTMB(effective.partners ~ density + (1|Species), family = "nbinom1", data = all)
AIC(m1, m2)
overdisp(m1)

m2 <- glmmTMB(effective.partners ~ Quantity+day + shrub.density +  (1|Species), family = "poisson", data = all)
summary(m2)
AIC(m1, m2)

m2 <- glmmTMB(lower.level.effective.partners ~ density + (1|Species), family = "nbinom2", data = all)

summary(m1)
AIC(m1, m2)


multicollin(m2)
r2(m2)
is_singular(m2)
overdisp(m1)

```

#Modules and modularity modelling

{r, module}
library(nnet)
m1 <- multinom(module ~ Species + shrub.density +  Quantity + N.flowers*day, data = all)
summary(m1)
car::Anova(m1)
ggplot(n1data, aes(module, N.flowers)) + geom_boxplot()


m2 <- multinom(module ~ Species + shrub.density +  Quantity +day, data = all)
AIC(m1,m2)
car::Anova(m2)
summary(m2)

kruskal.test(module ~ N.flowers, data = all)
kruskal.test(module ~ shrub.density, data = all)
kruskal.test(module ~ Quantity, data = all)

shapiro.test(all$connectivity)
ggplot(all, aes(connectivity)) + geom_density()

m <- lm(participation ~ shrub.density + Species, data = all)
shapiro.test(resid(m))
summary(m)

#violindles
ggplot(n1data, aes(module, day)) + geom_violin() + stat_summary(fun.y=mean, geom="point", shape=23, size=2) + geom_jitter(aes(color = Species), shape=16, position=position_jitter(0.2))